<!--
@license
Copyright (c) 2019 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.Overlay = window.Vaadin.Overlay || {};

  /**
   * @polymerMixin
   */
  Vaadin.Overlay.PositionMixin = superClass => class PositionMixin extends superClass {

    static get properties() {
      return {
        positionTarget: {
          type: Object,
          value: null
        },

        horizontalAlign: {
          type: String,
          value: 'start'
        },
        verticalAlign: {
          type: String,
          value: 'top'
        },

        noHorizontalOverlap: {
          type: Boolean,
          value: false
        },
        noVerticalOverlap: {
          type: Boolean,
          value: false
        }
      };
    }
    static get observers() {
      return [`__positionSettingsChanged(positionTarget, horizontalAlign, verticalAlign,
        noHorizontalOverlap, noVerticalOverlap)`];
    }

    connectedCallback() {
      super.connectedCallback();
      const boundUpdatePosition = this._updatePosition.bind(this);

      const computedStyle = getComputedStyle(this);
      this.__margins = {};
      ['top', 'bottom', 'left', 'right'].forEach(propName => {
        this.__margins[propName] = parseInt(computedStyle[propName], 10);
      });

      this.addEventListener('opened-changed', e => {
        const func = e.detail.value ? 'addEventListener' : 'removeEventListener';
        window[func]('scroll', boundUpdatePosition);
        window[func]('resize', boundUpdatePosition);
      });
    }

    __positionSettingsChanged() {
      setTimeout(() => this._updatePosition());
    }

    _updatePosition() {
      if (!this.positionTarget) {
        return;
      }
      const targetRect = this.positionTarget.getBoundingClientRect();

      const rtl = getComputedStyle(this).direction === 'rtl';

      const horizontalPosition = this.__calculateHorizontalPosition(targetRect, rtl);
      const verticalPosition = this.__calculateVerticalPosition(targetRect);

      const props = Object.fromEntries([horizontalPosition, verticalPosition]);
      this.__doSetPosition(props, rtl);
    }

    __calculateHorizontalPosition(targetRect, rtl) {
      const propNames = {
        start: 'left',
        end: 'right'
      };
      const overlayWidth = this.clientWidth;
      const contentWidth = this.$.content.clientWidth;
      const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
      const defaultAlignLeft = (!rtl && this.horizontalAlign === 'start') || (rtl && this.horizontalAlign === 'end');
      const currentAlignLeft = !!this.style.left;
      return PositionMixin.__calculatePositionInOneDimension(targetRect, overlayWidth, contentWidth,
        viewportWidth, this.__margins, defaultAlignLeft, currentAlignLeft, this.noHorizontalOverlap, propNames);
    }

    __calculateVerticalPosition(targetRect) {
      const propNames = {
        start: 'top',
        end: 'bottom'
      };
      const overlayHeight = this.clientHeight;
      const contentHeight = this.$.content.clientHeight;
      const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
      const defaultAlignTop = this.verticalAlign === 'top';
      const currentAlignTop = !!this.style.top;
      return PositionMixin.__calculatePositionInOneDimension(targetRect, overlayHeight, contentHeight,
        viewportHeight, this.__margins, defaultAlignTop, currentAlignTop, this.noVerticalOverlap, propNames);
    }

    static __calculatePositionInOneDimension(targetRect, overlaySize, contentSize, viewportSize, margins, defaultAlignStart, currentAlignStart, noOverlap, propNames) {
      const spaceForStartAlignment = viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];
      const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];

      const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;
      const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;

      const currentlyOnDefaultSide = currentAlignStart === defaultAlignStart;

      const shouldGoToDefaultSide = this.__shouldGoToDefaultSide(currentlyOnDefaultSide, overlaySize, contentSize, spaceForDefaultAlignment, spaceForOtherAlignment);

      const shouldAlignStart = (shouldGoToDefaultSide && defaultAlignStart) || (!shouldGoToDefaultSide && !defaultAlignStart);

      if (shouldAlignStart) {
        const cssPropName = propNames.start;
        const cssPropValue = targetRect[noOverlap ? propNames.end : propNames.start];
        return [cssPropName, cssPropValue];
      } else {
        const cssPropName = propNames.end;
        const cssPropValue = viewportSize - (targetRect[noOverlap ? propNames.start : propNames.end]);
        return [cssPropName, cssPropValue];
      }
    }

    static __shouldGoToDefaultSide(currentlyOnDefaultSide, overlaySize, contentSize, spaceOnDefaultSide, spaceOnOtherSide) {
      if (spaceOnDefaultSide > spaceOnOtherSide) {
        return true;
      }
      const fitsOnCurrentSide = contentSize < overlaySize;
      if (currentlyOnDefaultSide) {
        return fitsOnCurrentSide;
      }
      if (!fitsOnCurrentSide) {
        return false;
      }
      return contentSize < spaceOnDefaultSide;
    }

    __doSetPosition(cssProps, rtl) {
      ['left', 'right', 'top', 'bottom'].forEach(propName => {
        if (cssProps[propName] !== undefined) {
          this.style[propName] = cssProps[propName] + 'px';
        } else {
          this.style[propName] = '';
        }
      });

      const alignStart = (!rtl && cssProps.left) || (rtl && cssProps.right);
      this.style.alignItems = alignStart ? 'flex-start' : 'flex-end';

      this.style.justifyContent = cssProps.top ? 'flex-start' : 'flex-end';
    }

  };
</script>
